Operation Modes
===============

The library offers primitives to invoke planning engines of different kinds on problem specifications. In particular, the library uses the concept of operation modes to account for different possible interactions that can be performed with the planning engine at hand. Such operation modes allow the standardization of APIs towards different planning engineers sharing the same interaction kind and primitives.

We currently support the following operation modes:

* OneshotPlanning: is the classical interaction mode for the planning community, it consists in posing the planning problem entirely and then waiting for the solution. This operation mode does not support incremental reuse of information and is limited to one planning problem at a time, but is the most common operation model among the different planners available.
* PlanValidation: is an operation mode supporting the use case of checking the validity of a given plan against the problem specification. Essentially, the engine is required to analyse the given plan and report whether it is guaranteed to achieve the goal conditions or if instead it can fail due to an action not being applicable or a goal not being reached. For this operation mode, we also implemented a native engine that is part of the library itself.
* Compiling: is an operation mode that transforms a given problem into an equivalent one that doesn't make use of action parameters or first order predicates. The library implements several simplifications and compilations that can transform one problem into an equivalent one getting rid of some of the planning constructs. For example, we offer a functionality to remove conditional effects from the planning problem specification by compiling the input problem into an equivalent one that does not make use of conditional effects. Our architecture is very general and offers functionalities to transform a plan for the target problem of the compilation into a plan for the input problem. This allows the creation of pipelines of compilers that can map an input planning problem into an equivalent one supported by a target planning engine and then transform back the plan generated by the engine into a valid plan for the overall input problem.
* Simulation: is an operation mode that, given a problem, provides the functionalities to check if an action is applicable in a given state, to apply an action and generate the next state and to check if a given state is a goal state.

The solving interface also features a powerful automatic filtering of planning engines. In fact, the input planning problem is automatically analysed in order to determine the features needed to tackle the problem itself. The planning engines available on the system where the library is executed are then filtered, and only the ones that are capable of tackling the problem are left for the user to select from. This mechanism simplifies the job of the user in the selection of the right planning engine to be used.
All the functionalities of the solving interface are collected under the ``unified_planning.engines`` package.

Compiler Example
-------
The following example shows how to create a compiler to remove negative conditions from a problem and to retrieve the plan for the original problem from a plan of the transformed problem. If the planner does not support negative conditions, the original problem could not be solved, while the compiler allows us to solve the problem anyway.

.. literalinclude:: ./code_snippets/robot_battery.py
    :lines: 42-76

OneshotPlanner Example
-------

The following example shows how to get a planner and solve a problem.

.. literalinclude:: ./code_snippets/robot_battery.py
    :lines: 80-86
