syntax = "proto3";



// =============== Types ================

// We need to express types (of a paramater, of a fluent).
// There are two options for this: 
//  (1) a structure with several options, or 
//  (2) a string representation of the type.
// I find the former a bit heavy to work with and would suggest to just represent it a string.

// Built-in types
//  - "bool"
//  - "int"
//  - "real"
//
// Any other string (e.g. "location") refers to a symbolic type and must have been declared in the problem definition.

// Declares the existence of a type (same as in PDDL)
message TypeDeclaration {
    // Type that is declared.
    string type_name = 1;
    // If the string is non-empty, this is the parent type of `type_name`.
    // If set, the parent type must have been previously declared (i.e. should appear earlier in the problem's type declarations.
    string parent_type = 2;
}

// We can also consider restrictions to int/reals with specific syntax (e.g. "int[0,100]")
// but we need to agree on the semantics and syntax.


// ================== Expressions ====================


// As in s-expression, an Expression is either an atom or list representing the application of some parameters to a function/fluent.
message Expression {
    oneof content {
        // The expression is a single atom.
        // For instance `3`, `+`, `kitchen`, `at-robot`, ...
        Atom atom = 1;
        // The expression is a list, typically representing the application of some arguments to a function or fluent.
        // For instance `(+ 1 3)`, (at-robot l1)`, `(>= (battery_level) 20)`
        repeated Expression list = 2;
    }
    // Type of the expression. For instance "int", "location", ...
    string type = 3;
    // Kind of the expression, specifying the content of the expression. 
    // This is intended to facilitate parsing of the expression.
    ExpressionKind kind = 4;
}


enum ExpressionKind {
    // Default value, should not be used. Drop it if we are sure to never need it.
    UNKNOWN = 0;
    // Constant atom. For instance `3` or `kitchen` (where `kitchen` is an object defined in the problem)
    CONSTANT = 1;
    // Atom symbol representing a parameter from an outer scope. For instance `from` that would appear inside a `(move from to - location)` action.
    PARAMETER = 2;
    // Atom symbol reprenting a fluent of the problem. For instance `at-robot`.
    FLUENT_SYMBOL = 3;
    // Atom representing a function. For instance `+`, `=`, `and`, ...
    FUNCTION_SYMBOL = 4;
    // List. Application of some parameters to a fluent symbol. For instance `(at-robot l1)` or `(battery-charged)`
    // The first element of the list must be a FLUENT_SYMBOL
    STATE_VARIABLE = 5;
    // List. The expression is the application of some parameters to a function. For instance `(+ 1 3)`.
    // The first element of the list must be a FUNCTION_SYMBOL
    FUNCTION_APPLICATION = 6;
}


message Atom {
    oneof content {
        string symbol = 1;
        int64 int = 2;
        double float = 3;
        bool boolean = 4;
    }
}



// ============= Domains ====================

// Parameter of a fluent or of an action
message Parameter {
    string name = 1;
    string type = 2; 
}


// A state-dependent variable.
message Fluent {
    string name = 1;
    // Return type of the fluent.
    string value_type = 2;
    // Typed and named parameters of the fluent.
    repeated Parameter parameters = 3;
}


// Declares an object with the given name and type.
// Type must be a previously declared symbolic type.
message ObjectDeclaration {
    string name = 1;
    string type = 2; 
}





// ========= Actions ========



// An effect expression is of the form `FLUENT OP VALUE`.
// We explicitly restrict the different types of effects by setting the allowed operators.
message EffectExpression {
    enum Operator {
        // This is the value that will be taken if the operator is not explicitly set.
        // It is currently a logic error to have this value but is needed to allow later extensions.
        UNDEFINED = 0;
        // The `fluent` is set to the corresponding `value`
        ASSIGN = 1;
        // The `fluent` is increased by the amount `value`
        // features: [numeric?]
        INCREASE = 2;
    }
    
    // Expression that must be of the STATE_VARIABLE kind.
    Expression fluent = 1;
    Operator op = 2;
    Expression value = 3;
}

// Representation of an effect that allows qualifying the effect expression, e.g., to make it a conditional effect.
message Effect {
    // Required. The actual effect that should take place.
    EffectExpression effect = 1; 
    // Optional. If the effect is conditional, then the following field must be set.
    // In this case, the `effect` will only be applied if the `condition`` holds.
    // TODO: When should the condition hold in case of durative actions? Is this supported by PDDL? Two options:
    //        - immediately before the effect (generalization of the non-temporal case)
    //        - have the condition field be of type `Condition` which allows for temporal qualification. If not qualified, the above would apply.
    // features: [conditional_effects]
    Expression condition = 2;
    // Optional. If the effect is within a durative action, the following must be set and will specify when the effect takes place.
    // features: [durative_actions]
    TemporalQualification temporal_qualification = 3;
}


message Condition {
    Expression cond = 1;
    // Optional. Must be set for durative actions where it specifies when the condition should hold.
    // features: [durative_actions]
    TemporalQualification temporal_qualification = 2;
}

// Unified action representation that should representing all kinds of actions.
message Action {
    // .Action name. E.g. "move"
    string name = 1;
    
    // Typed and named parameters of the action.
    repeated Parameter parameters = 2;

    // If set, the action is durative. Otherwise it is instantaneous.
    // features: [durative_actions]
    Duration duration = 3;
    
    // Conjunction of conditions that must hold for the action to be applicable.
    repeated Condition conditions = 4;

    // Conjunction of effects as a result of applying this action.
    repeated Effect effects = 5;

    // Cost of the action.
    // features: [action_costs]
    Expression cost = 6;
}


message TemporalQualification { /* TODO */ }
message Duration { /* TODO */ }




// ============== Problem =========================


// A Goal is currently an expression that must hold in the final state.
// It is in its own message to allow its extension with (e.g.):
//  - temporal qualification
//  - weight (for optional goals, oversubscription planning)
message Goal {
    // Goal expression that must hold in the final state.
    Expression goal = 1;
}

// An initial or timed fact.
message Fact {
    // If the `temporal_qualification` field if not set (which is guaranteed to be the case without the `timed_facts` feature),
    // then it represents an initial fact and:
    //  - the operator of the effect MUST be an ASSIGN
    //  - the effect will be applied to the initial state.
    EffectExpression fact = 1;
    // If set, the fact will not hold at the initial state but instead according to the given temporal qualification.
    // In that case, it makes sense to have non-assign effects (e.g. "at time 100, increase stock by 10")
    // features: [timed_facts]
    TemporalQualification temporal_qualification = 2;
}

message Problem {
    string domain_name = 1;
    string problem_name = 2;
    repeated TypeDeclaration types = 3;
    repeated Fluent fluents = 4;
    repeated ObjectDeclaration objects = 5;

    // list of actions (the type and different fields might depend on the retained proposal)
    repeated Action actions = 6;

    // Initial facts and timed facts (under the `timed_facts` feature).
    repeated Fact facts = 7;
    repeated Goal goals = 8;

    // all features of the problem
    repeated Feature features = 15;
}

// Features of the problem.
// Features are essential in that not supporting a feature `X` should allow disregarding any field tagged with `features: [X]`.
enum Feature {
    DURATIVE_ACTIONS = 0;
    CONDITIONAL_EFFECTS = 1; 
    ACTION_COSTS = 2;
    TIMED_FACTS = 3;
}


// =================== Plan ================





// Representation of an action instance that appears in a plan.
message ActionInstance {
    // Optional. A unique identifier of the action that might be used to refer to it (e.g. in HTN plans).
    string id = 1;
    // name of the action 
    string action_name = 2;
    // Parameters of the action instance, required to constants (kind = CONSTANT).
    repeated Atom parameters = 3;
    // Start time of the action. The default 0 value is OK in the case of non-temporal planning
    // feature: [durative_actions]
    double start_time = 4; 
    // End time of the action. The default 0 value is OK in the case of non-temporal planning
    // feature: [durative_actions]
    double end_time = 5; 

}

message Plan {
    // An ordered sequence of actions that appear in the plan.
    // The order of the actions in the list must be compatible with the partial order of the start times.
    // In case of non-temporal planning, this allows having all start time at 0 and only rely on the order in this sequence.
    repeated Action actions = 1;
    // TODO: add an optional cost field?
}






// =============== RPC API =======================

message PlanRequest {
    // Problem that should be solved.
    Problem problem = 1;

    enum Mode {
        SATISFIABLE = 0;
        OPTIMAL = 1;
    }
    Mode resolution_mode = 2;
    
    // max allowed runtime time in milliseconds 
    // (maybe a deadline would be better if we are considering milliseconds?)
    double timeout_seconds = 3;

    // Planner specific options to be passed to the planner
    map<string, string> planner_options = 4;
}






// Intermediate report sent by the planner while running.
message Report {
    // Optional. If set, it is the latest found plan not already reported.
    Plan plan = 1;

    // ==== Logging ====
    // the following is a very early draft to allow semi-structured feedback from the planner.

    // To be refined with different log levels: INFO, WARNING, ERROR
    // We would want to display warning and error messages by default.
    string log_message = 2;

    // Planner specific messages
    map<string, string> metrics = 3;
}

// Last message sent by planner before exiting.
// Contains the planner exit status as well as the best plan found if any.
message Stopped {
    enum Status {
        // Valid plan found and search stopped immediately
        SAT = 0;
        // Plan found with optimality guarantee
        OPT = 1;
        // No plan exists
        UNSAT = 2;
        // The planner was not able to find a solution but does not give any guarantee that none exist
        // (i.e. the planner might not be complete)
        SEARCH_SPACE_EXHAUSTED = 3;

        // Search stopped before concluding OPT or UNSAT
        // If a plan was found, it might be reported in the `best_plan` field
        TIMEOUT = 13;
        MEMOUT = 14;
        INTERNAL_ERROR = 15;
        UNSUPPORTED_PROBLEM = 16;
    }
    Status status = 1;

    // Optional. Debug information (to be used in conjunction with INTERNAL_ERROR or UNSUPPORTED_PROBLEM).
    string error_message = 4;

    // Optional. Best plan found if any.
    Plan best_plan = 2;

    // a set of planner specific values that can be reported, for instance
    // - "grounding-time": "10ms"
    // - "expanded-states": "1290"
    map<string, string> metrics = 3;
}



message Answer {
    oneof content {
        Report report = 1;
        Stopped stopped = 2;
    }
}


service Upf {
    // A plan request to the planner.
    // The planner replies with a stream of N `Answer` messages where:
    //  - the first (N-1) message are of type `Report`
    //  - the last message is of type `Stopped`
    rpc plan(PlanRequest) returns(stream Answer);


    // ===== About bidirectional interaction =====

    // The scheme above does not allow send info to the planner after the initial request.
    // gRPC might allow some limited form of interactions such as setting deadlines, 
    // cancel request or terminate an RPC. (https://www.grpc.io/docs/what-is-grpc/core-concepts/)
    
    // With the current UPF feature set, the above plan API is likely to be sufficient.
    // In the future we might want to extend the API to have a stream of message sen to the planner.
    // rpc plan(stream Request) returns(stream Answer);
} 